//
// Source code recreated from a .class file by IntelliJ IDEA
// (powered by Fernflower decompiler)
//


import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import java.io.BufferedReader;
import java.io.DataOutputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.HttpURLConnection;
import java.net.URL;
import java.util.ArrayList;
import java.util.List;


public class ClientServlet extends HttpServlet {

    protected static final String MISP_BRIDGE_URL = "http://localhost:9090/mispbridge/core";

    public List<Ride> availableRides = new ArrayList<>();
    public List<Ride> reservedRides = new ArrayList<>();
    public List<Ride> pendingRequests = new ArrayList<>();
    public List<Ride> pendingData = new ArrayList<>();

    public ClientServlet() {

        // Thread : while AvailableRides < 256 , add Ride to AvailableRides , send POST (Ride) [DONE]
        new Thread(new PostRideRunnable(this)).start();

        // Thread : for Rides in ReservedRides, send GET (Ride)
        new Thread(new GetRideRunnable(this)).start();
    }


    /**
     * # send POST (Ride)
     * Generated by Loop
     */
    Ride sendPostRide(Ride oldRide) throws IOException, ServletException {

        HttpURLConnection connection = ConnectionHelper.make("POST", MISP_BRIDGE_URL);

        // send POST (Ride)
        availableRides.add(oldRide);
        connection.setDoOutput(true);
        DataOutputStream outputStream = new DataOutputStream(connection.getOutputStream());
        outputStream.writeBytes(oldRide.json());
        outputStream.flush();
        outputStream.close();

        // handle OK (Ride)
        // remove Ride from AvailableRides
        // add Ride to ReservedRides
        if (connection.getResponseCode() == 200) {
            Ride parsedRide = ConnectionHelper.parseRide(connection);
            if (parsedRide.equals(oldRide)) {
                availableRides.remove(oldRide);
                reservedRides.add(parsedRide);
                return parsedRide;
            }
        }
        return null;
    }


    /**
     * # send GET (Ride)
     * Generated by Loop
     */
    Ride sendGetRide(Ride oldRide) throws IOException {

        HttpURLConnection connection = ConnectionHelper.make("GET", MISP_BRIDGE_URL);

        // send GET (Ride)
        connection.setDoOutput(true);
        DataOutputStream outputStream = new DataOutputStream(connection.getOutputStream());
        outputStream.writeBytes(oldRide.json());
        outputStream.flush();
        outputStream.close();

        // handle OK (Ride)(Request)
        // remove Ride from ReservedRides
        // add Ride to PendingRequests
        // send GET (Request)
        if (connection.getResponseCode() == 200) {
            Ride parsedRide = ConnectionHelper.parseRide(connection);
            if (parsedRide.getRequest() != null) {
                reservedRides.remove(oldRide);
                pendingRequests.add(parsedRide);
                sendGetRequest(parsedRide);
                return parsedRide;
            }
        }
        return null;
    }

    /**
     * # send GET (Request) to App
     */
    Ride sendGetRequest(Ride oldRide) throws IOException {

        // send FOO
        // TODO make sure as many as possible tyes of requests can be forwarded.

        // handle OK (Data)
        // remove Ride from PendingRequests
        // add Ride to PendingData
        // send GET (Ride)(Data)
        String data = "DATA";
        pendingRequests.remove(oldRide);
        Ride newRide = oldRide;
        newRide.setData(data);
        pendingData.add(newRide);
        sendGetRideRequestData(newRide);
        return newRide;
    }


    /**
     * # send GET (Ride)(Request)(Data)
     */
    Ride sendGetRideRequestData(Ride oldRide) throws IOException {

        HttpURLConnection connection = ConnectionHelper.make("GET", MISP_BRIDGE_URL);

        // send GET (Ride)(Request)(Data)
        connection.setDoOutput(true);
        DataOutputStream outputStream = new DataOutputStream(connection.getOutputStream());
        outputStream.writeBytes(oldRide.json());
        outputStream.flush();
        outputStream.close();

        // handle OK (EOL)
        // remove Ride from PendingData
        // add Ride to EOl
        if (connection.getResponseCode() == 200) {
            Ride shellIdRide = ConnectionHelper.parseRide(connection);
            if (shellIdRide.getRideID() != null) {
                pendingData.remove(oldRide);
            }
        }
        return null;
    }


}


/**
 * While AvailableRides < 256 ,
 * add Ride to AvailableRides ,
 * send POST (Ride).
 */
class PostRideRunnable implements Runnable {

    ClientServlet clientServlet;

    public PostRideRunnable(ClientServlet clientServlet) {
        this.clientServlet = clientServlet;
    }

    @Override
    public void run() {
        while (true) {
            if (clientServlet.availableRides.size() < 1) {
                try {clientServlet.sendPostRide(new Ride());} catch (IOException | ServletException e) { e.printStackTrace(); }
            }
            try {Thread.sleep(500);} catch (InterruptedException e) { e.printStackTrace(); }
        }
    }
}


/**
 * For Rides in ReservedRides,
 * send GET (Ride).
 */
class GetRideRunnable implements Runnable {
    ClientServlet clientServlet;

    public GetRideRunnable(ClientServlet clientServlet) {
        this.clientServlet = clientServlet;
    }

    @Override
    public void run() {
        while (true) {
            for (Ride reservedRide : clientServlet.reservedRides) {
                try {clientServlet.sendGetRide(reservedRide);} catch (IOException e) { e.printStackTrace(); }
            }
            try {Thread.sleep(500);} catch (InterruptedException e) { e.printStackTrace(); }
        }
    }
}